#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Generate a comprehensive English Word (.docx) document describing the MiniMony project.
The script inspects key files and the repository layout and writes a structured document.
"""
import os
import datetime
from docx import Document
from docx.shared import Pt
from docx.enum.text import WD_PARAGRAPH_ALIGNMENT

ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
IGNORED_DIRS = {'.git', '__pycache__', '.venv', 'venv', 'node_modules'}
MAX_SNIPPET_LINES = 120


def add_heading(doc, text, level=1):
    doc.add_heading(text, level=level)


def add_paragraph(doc, text, size=11, bold=False):
    p = doc.add_paragraph()
    run = p.add_run(text)
    run.font.name = 'Arial'
    run.font.size = Pt(size)
    run.bold = bold
    return p


def add_code_block(doc, code_text, size=9):
    p = doc.add_paragraph()
    p.alignment = WD_PARAGRAPH_ALIGNMENT.LEFT
    run = p.add_run(code_text)
    run.font.name = 'Consolas'
    run.font.size = Pt(size)
    return p


def read_file_snippet(path, max_lines=MAX_SNIPPET_LINES):
    try:
        with open(path, 'r', encoding='utf-8', errors='replace') as f:
            lines = f.readlines()
    except Exception as e:
        return f'Could not read file: {e}'
    if not lines:
        return ''
    return ''.join(lines[:max_lines])


def collect_tree(root):
    tree = []
    for dirpath, dirnames, filenames in os.walk(root):
        parts = dirpath.split(os.sep)
        if any(p in IGNORED_DIRS for p in parts):
            continue
        rel = os.path.relpath(dirpath, root)
        tree.append((rel, sorted(filenames)))
    return tree


def build_document(root):
    doc = Document()

    # Title
    add_heading(doc, 'MiniMony — Project Overview', level=1)
    meta = f'Generated: {datetime.datetime.now().strftime("%Y-%m-%d %H:%M")}'
    add_paragraph(doc, meta, size=9)

    # Short description (from README if present)
    add_heading(doc, 'Project Summary', level=2)
    readme_path = os.path.join(root, 'README_LIVE_SHARE.md')
    if os.path.exists(readme_path):
        snippet = read_file_snippet(readme_path, max_lines=200)
        add_paragraph(doc, 'The repository includes a small README for Live Share guests. Excerpt:')
        add_code_block(doc, snippet)
    else:
        add_paragraph(doc, 'No README found. This document was generated by inspecting the repository.')

    # Features / Purpose
    add_heading(doc, 'Purpose & Features', level=2)
    add_paragraph(doc, 'MiniMony appears to be a scraping-oriented project with a small Flask web UI. Key points:')
    add_paragraph(doc, '- Scrapers ("scraptors") for multiple sites, located under `src/scraptor`')
    add_paragraph(doc, '- Central orchestration in `src/main.py` to discover and run scraptors in parallel')
    add_paragraph(doc, '- A lightweight Flask web interface under `src/gui/web` with a helper `run_flask.py`')

    # How it works
    add_heading(doc, 'How It Works', level=2)
    add_paragraph(doc, 'High-level flow:')
    add_paragraph(doc, '1. `src/main.py` discovers scraptor modules in `src/scraptor/*` and runs them either sequentially or using a process pool.')
    add_paragraph(doc, '2. Each scraptor implements a `run()` function that returns scraped data.')
    add_paragraph(doc, '3. The web UI (Flask) exposes a simple interface to view or trigger scraping (see `src/gui/web/main.py`).')

    # Key files
    add_heading(doc, 'Key Files & Excerpts', level=2)

    # run_flask.py
    rf_path = os.path.join(root, 'run_flask.py')
    if os.path.exists(rf_path):
        add_paragraph(doc, 'run_flask.py — helper to launch the Flask app (for Live Share / Codespace guests):', bold=True)
        add_code_block(doc, read_file_snippet(rf_path, max_lines=200))

    # src/main.py
    sm_path = os.path.join(root, 'src', 'main.py')
    if os.path.exists(sm_path):
        add_paragraph(doc, 'src/main.py — orchestrates scraptor discovery and execution:', bold=True)
        add_code_block(doc, read_file_snippet(sm_path, max_lines=300))

    # GUI main
    gui_main_path = os.path.join(root, 'src', 'gui', 'web', 'main.py')
    if os.path.exists(gui_main_path):
        add_paragraph(doc, 'src/gui/web/main.py — Flask web application entry point:', bold=True)
        add_code_block(doc, read_file_snippet(gui_main_path, max_lines=300))

    # Directory tree
    add_heading(doc, 'Repository Layout', level=2)
    tree = collect_tree(root)
    for rel, files in sorted(tree):
        add_paragraph(doc, f'- {rel} : {", ".join(files)}')

    # How to run
    add_heading(doc, 'How to Run Locally', level=2)
    add_paragraph(doc, 'Prerequisites: Python 3.8+ and the `python-docx` library is used only for this document generator.')
    add_paragraph(doc, 'Start Flask app (recommended for Live Share guests):')
    add_code_block(doc, 'python run_flask.py\n# or run src/gui/web/main.py directly')

    # Notes and next steps
    add_heading(doc, 'Notes & Next Steps', level=2)
    add_paragraph(doc, '- Tests: repository contains a `tests/` folder with small checks; expand for CI.')
    add_paragraph(doc, '- Packaging: consider a `requirements.txt` or `pyproject.toml` to lock deps.')
    add_paragraph(doc, '- Error handling and logging: ensure scraptors log structured output for easier aggregation.')

    return doc


if __name__ == '__main__':
    out = os.path.join(ROOT, 'MiniMony_comprehensive_en.docx')
    doc = build_document(ROOT)
    doc.save(out)
    print('Saved:', out)
